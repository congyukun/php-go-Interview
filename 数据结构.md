# 一、数组（Array）

## （一）概念

- 数组是一种线性的数据结构，它是由相同类型的元素组成的有序集合。这些元素在内存中是连续存储的，通过索引来访问其中的元素。例如，一个整数数组`int[] arr = {1, 2, 3, 4, 5}`，可以通过`arr[0]`访问第一个元素 1，`arr[2]`访问第三个元素 3。

## （二）操作

- **访问元素**：时间复杂度为$O(1)$，因为可以通过索引直接定位元素。例如，在一个长度为 n 的数组中访问第 i 个元素，计算索引位置后直接读取内存即可。
- **插入元素**：
  - 在数组末尾插入元素时间复杂度为$O(1)$，只需要在末尾添加元素即可。
  - 在数组中间插入元素时间复杂度为$O(n)$，因为需要将插入位置后的元素依次向后移动一个位置，为新元素腾出空间。例如，在`{1, 2, 3, 4, 5}`的第二个位置插入一个元素 6，需要将 3、4、5 依次向后移动，变为`{1, 6, 2, 3, 4, 5}`。
- **删除元素**：
  - 在数组末尾删除元素时间复杂度为$O(1)$，直接删除即可。
  - 在数组中间删除元素时间复杂度为$O(n)$，因为需要将删除位置后的元素依次向前移动一个位置来填补空缺。例如，在`{1, 2, 3, 4, 5}`中删除第二个元素 2，需要将 3、4、5 依次向前移动，变为`{1, 3, 4, 5}`。

## （三）应用场景

- 数组适用于存储和操作一组相同类型的数据，如存储学生成绩列表、图像的像素点等。在需要频繁访问元素且数据量相对固定的情况下，数组是很好的选择。例如，在一个图像编辑软件中，用数组来存储图像的像素颜色值，方便快速读取和修改特定像素的颜色。

# 二、链表（Linked List）

## （一）概念

- 链表是一种非连续存储的数据结构，由一系列节点组成。每个节点包含数据部分和指向下一个节点的指针。例如，单链表节点结构可以是`class Node { int data; Node next; }`，通过节点之间的指针链接形成链表。

## （二）操作

- **访问元素**：时间复杂度为$O(n)$，因为需要从链表头开始逐个节点遍历，直到找到目标节点。例如，在一个长度为 n 的链表中找第 i 个节点，需要遍历 i - 1 个节点。
- **插入元素**：
  - 在链表头部插入元素时间复杂度为$O(1)$，只需要创建新节点，将新节点的指针指向原头节点，然后将新节点设为头节点。
  - 在链表中间插入元素时间复杂度为$O(n)$，需要先找到插入位置的前驱节点，然后插入新节点。例如，在一个有序链表中插入一个新节点，使其仍然保持有序，需要先遍历找到合适的插入位置。
- **删除元素**：
  - 在链表头部删除元素时间复杂度为$O(1)$，只需要将头节点指向下一个节点即可。
  - 在链表中间删除元素时间复杂度为$O(n)$，需要先找到要删除节点的前驱节点，然后修改前驱节点的指针。例如，在一个链表中删除指定值的节点，需要先遍历找到该节点及其前驱节点。

## （三）应用场景

- 链表适用于需要频繁插入和删除元素的场景。例如，在实现一个简单的任务队列时，当有新任务加入或者完成任务需要删除时，链表的插入和删除操作比较方便。

# 三、栈（Stack）

## （一）概念

- 栈是一种特殊的线性数据结构，它遵循后进先出（LIFO - Last In First Out）的原则。可以把栈想象成一个只有一端开口的容器，元素只能从这个开口进出。例如，有一个栈，依次放入元素 1、2、3，那么取出元素时，先取出 3，再取出 2，最后取出 1。

## （二）操作

- **入栈（Push）**：时间复杂度为$O(1)$，将元素添加到栈顶。
- **出栈（Pop）**：时间复杂度为$O(1)$，移除栈顶元素。
- **查看栈顶元素（Peek）**：时间复杂度为$O(1)$，返回栈顶元素但不移除。

## （三）应用场景

- 栈在表达式求值、函数调用（函数调用栈）等场景中有广泛应用。例如，在计算一个算术表达式`3 + 4 * 2`时，可以用栈来存储操作数和运算符，按照运算符的优先级进行计算。

# 四、队列（Queue）

## （一）概念

- 队列是一种线性数据结构，遵循先进先出（FIFO - First In First Out）的原则。可以类比为排队，先进入队列的元素先被处理。例如，在银行排队办理业务，先排队的人先办理。

## （二）操作

- **入队（Enqueue）**：时间复杂度为$O(1)$，将元素添加到队尾。
- **出队（Dequeue）**：时间复杂度为$O(1)$，将队头元素移除。
- **查看队头元素（Peek）**：时间复杂度为$O(1)$，返回队头元素但不移除。

## （三）应用场景

- 队列常用于任务调度、广度优先搜索（BFS）等场景。例如，在一个打印任务管理系统中，多个打印任务按照提交的先后顺序排队等待打印，就可以用队列来管理这些任务。

# 五、树（Tree）

## （一）概念

- 树是一种非线性的数据结构，它由节点（Node）和边（Edge）组成。有一个特殊的节点称为根节点（Root），其余节点通过边连接，并且每个节点可以有零个或多个子节点。例如，二叉树是一种特殊的树，每个节点最多有两个子节点，分别称为左子节点和右子节点。

## （二）操作

- **遍历**：
  - 前序遍历：根节点 - 左子树 - 右子树。例如，对于二叉树，先访问根节点的值，然后递归地遍历左子树和右子树。时间复杂度为$O(n)$，其中$n$是树中节点的数量。
  - 中序遍历：左子树 - 根节点 - 右子树。常用于二叉搜索树（BST）来获取有序的数据序列。时间复杂度同样为$O(n)$。
  - 后序遍历：左子树 - 根节点 - 右子树。在一些计算树的叶子节点相关的操作时很有用，时间复杂度为$O(n)$。
- **插入（针对二叉搜索树）**：在二叉搜索树中插入一个节点，首先要找到合适的插入位置。时间复杂度取决于树的高度，平均时间复杂度为$O(log n)$，最坏情况（树退化为链表）为$O(n)$。
- **删除（针对二叉搜索树）**：找到要删除的节点并调整树的结构。平均时间复杂度为$O(log n)$，最坏情况为$O(n)$。

## （三）应用场景

- 树结构在文件系统、数据库索引（如 B - 树、B + 树）、HTML 和 XML 文档解析等场景中广泛应用。例如，在文件系统中，目录和文件的组织就可以看作是树结构，根目录是树的根节点，子目录和文件是子节点。

# 六、图（Graph）

## （一）概念

- 图是一种更为复杂的非线性数据结构，由顶点（Vertex）和边（Edge）组成。边用于连接顶点，表示顶点之间的关系。图可以是有向图（边有方向）或无向图（边没有方向）。例如，在社交网络中，可以用图来表示用户之间的好友关系，用户是顶点，好友关系是边。

## （二）操作

- **遍历**：
  - 广度优先搜索（BFS）：从一个起始顶点开始，先访问距离起始顶点最近的顶点，然后逐步向外扩展。时间复杂度为$O(V + E)$，其中$V$是顶点的数量，$E$是边的数量。
  - 深度优先搜索（DFS）：从一个起始顶点开始，沿着一条路径尽可能深地访问顶点，直到不能继续，然后回溯。时间复杂度同样为$O(V + E)$。
- **最短路径算法（如 Dijkstra 算法）**：用于在图中找到一个顶点到其他顶点的最短路径。时间复杂度为$O((V + E)log V)$，适用于边的权重非负的情况。

## （三）应用场景

- 图在社交网络分析、交通路线规划、计算机网络拓扑结构等众多领域有广泛应用。例如，在地图导航软件中，用图来表示道路网络，通过最短路径算法为用户规划最佳出行路线。

# 七、哈希表（Hash Table）

## （一）概念

- 哈希表也叫散列表，是一种根据关键码值（Key）而直接进行访问的数据结构。它通过一个哈希函数（Hash Function）将关键码值映射到一个数组中的特定位置来存储值（Value）。例如，有一个简单的哈希函数$h(key) = key \% 10$，如果要存储键值对$(13, "apple")$，则通过哈希函数计算得到索引为 3，将值存储在数组索引为 3 的位置。

## （二）操作

- **插入**：通过哈希函数计算键对应的索引，然后将键值对存储在该索引位置。理想情况下，时间复杂度为$O(1)$，但在发生哈希冲突（不同的键通过哈希函数得到相同的索引）时，可能需要额外的处理，如链地址法（将冲突的键值对存储在链表中）或开放寻址法（寻找下一个可用的存储位置）。
- **查找**：同样先通过哈希函数计算索引，然后在该索引位置查找键。理想情况下时间复杂度为$O(1)$，但在哈希冲突较多时，时间复杂度可能会增加。
- **删除**：先找到要删除的键的位置，然后删除键值对。和查找操作类似，理想情况时间复杂度为$O(1)$，实际情况可能受哈希冲突影响。

## （三）应用场景

- 哈希表在数据存储和检索场景中应用广泛，如数据库索引、缓存系统等。例如，在一个缓存系统中，用哈希表存储缓存数据，通过键快速查找和获取缓存的值，提高数据访问速度。

# 八、堆（Heap）

## （一）概念

- 堆是一种特殊的完全二叉树数据结构。分为最大堆和最小堆。在最大堆中，每个节点的值都大于或等于它的子节点的值；在最小堆中，每个节点的值都小于或等于它的子节点的值。例如，在一个最大堆`[9, 7, 5, 3, 1]`（用数组表示二叉树），根节点 9 是最大的，它的子节点 7 和 5 都小于 9。

## （二）操作

- **插入元素**：将元素插入到堆的末尾，然后通过向上调整（上浮）操作来维护堆的性质。时间复杂度为$O(log n)$，其中$n$是堆中元素的数量。例如，在一个最小堆中插入一个新元素，如果这个元素比它的父节点小，就交换它们的位置，直到满足最小堆的性质。
- **删除堆顶元素**：在最大堆中删除堆顶（最大值），或在最小堆中删除堆顶（最小值）。先将堆的最后一个元素移到堆顶，然后通过向下调整（下沉）操作来维护堆的性质。时间复杂度为$O(log n)$。例如，在最大堆中，将最后一个元素移到堆顶后，如果它小于它的子节点，就与较大的子节点交换位置，直到满足最大堆的性质。
- **获取堆顶元素**：时间复杂度为$O(1)$，直接返回堆顶元素的值。

## （三）应用场景

- 堆常用于实现优先队列，在任务调度（按照任务优先级执行）、排序算法（如堆排序）、图形处理（例如，Dijkstra 算法中寻找最短路径时的优先队列）等场景中发挥重要作用。例如，在操作系统的进程调度中，根据进程的优先级将进程放入最大堆中，每次调度时选择堆顶（优先级最高）的进程来执行。

# 九、字典树（Trie）

## （一）概念

- 字典树，也叫前缀树，是一种树形结构。它用于存储字符串集合，其节点通常不存储完整的字符串，而是存储字符串中的单个字符。从根节点到某个节点的路径表示一个字符串的前缀。例如，存储单词“apple”、“application”、“banana”，根节点没有字符，它的子节点可能有字符‘a’和‘b’，从根节点到存储‘p’的节点路径可以表示“ap”这个前缀。

## （二）操作

- **插入字符串**：从根节点开始，逐个字符插入。如果字符对应的节点不存在，就创建新节点。时间复杂度为$O(m)$，其中$m$是要插入字符串的长度。例如，插入单词“cat”，如果根节点没有‘c’这个子节点，就创建一个新节点存储‘c’，然后依次插入‘a’和‘t’对应的节点。
- **查询字符串**：从根节点开始，沿着字符串的字符路径查找。如果能顺利找到最后一个字符对应的节点，说明字符串存在。时间复杂度为$O(m)$。例如，查找单词“dog”，从根节点开始找‘d’、‘o’、‘g’对应的节点，如果都能找到，则单词存在。
- **删除字符串**：相对复杂，需要考虑删除节点后是否会影响其他字符串的前缀路径。一般先查询字符串是否存在，然后删除节点并调整树的结构。时间复杂度为$O(m)$。

## （三）应用场景

- 字典树主要用于字符串的快速检索、自动补全、拼写检查等应用。例如，在搜索引擎的输入框自动补全功能中，当用户输入部分字符时，通过字典树快速查找以这些字符开头的所有可能单词并提供补全建议。

# 以下是链表几种分类的图示及相关说明：

### 一、单链表（Singly - Linked List）

**图示**：

```
     +---+    +---+    +---+    +---+
     | 1 | -> | 3 | -> | 5 | -> | 7 | -> NULL
     +---+    +---+    +---+    +---+
```

在这个单链表示例中，每个节点包含一个数据域（这里存储整数）和一个指向下一个节点的指针（next 指针）。最后一个节点的 next 指针指向 NULL，表示链表的结尾。

**操作示例图示**：

- **插入节点（头部插入）**：

假设要在上述单链表头部插入数据为 `0` 的节点。

```
     +---+    +---+    +---+    +---+
NULL -> | 0 | -> | 1 | -> | 3 | -> | 5 | -> | 7 | -> NULL
     +---+    +---+    +---+    +---+    +---+
```

操作步骤：

1. 创建新节点存储数据 `0`。
2. 将新节点的 next 指针指向原头节点（存储 `1` 的节点）。
3. 将新节点设为头节点，此时链表的头指针指向新节点。

- **插入节点（中间插入，比如在 `3` 和 `5` 之间插入 `4`）**：

```
     +---+    +---+    +---+    +---+    +---+
     | 1 | -> | 3 | -> | 4 | -> | 5 | -> | 7 | -> NULL
     +---+    +---+    +---+    +---+    +---+
```

操作步骤：

1. 从链表头开始遍历，找到存储 `3` 的节点（插入位置的前驱节点）。
2. 创建新节点存储数据 `4`。
3. 将新节点的 next 指针指向存储 `5` 的节点（原前驱节点的下一个节点）。
4. 将存储 `3` 的节点的 next 指针指向新节点。

- **删除节点（删除头节点）**：

```
     +---+    +---+    +---+    +---+
     | 3 | -> | 5 | -> | 7 | -> NULL
     +---+    +---+    +---+    +---+
```

操作步骤：

1. 将头节点（存储 `1` 的节点）的下一个节点（存储 `3` 的节点）设为新的头节点。
2. 原头节点的存储空间可根据具体情况进行释放（在编程语言中通过相应的内存管理机制实现）。

- **删除节点（删除中间节点，比如存储 `5` 的节点）**：

```
     +---+    +---+    +---+    +---+
     | 1 | -> | 3 | -> | 7 | -> NULL
     +---+    +---+    +---+    +---+
```

操作步骤：

1. 从链表头开始遍历，找到存储 `3` 的节点（要删除节点 `5` 的前驱节点）。
2. 将存储 `3` 的节点的 next 指针指向存储 `5` 的节点的下一个节点（存储 `7` 的节点）。
3. 存储 `5` 的节点的存储空间可根据具体情况进行释放。

### 二、双链表（Doubly - Linked List）

**图示**：

```
     +---+    +---+    +---+    +---+
NULL <- | 1 | <-> | 3 | <-> | 5 | <-> | 7 | -> NULL
     +---+    +---+    +---+    +---+
```

在双链表中，每个节点除了有指向下一个节点的 next 指针，还有指向前一个节点的 prev 指针。头节点的 prev 指针指向 NULL，尾节点的 next 指针也指向 NULL。

**操作示例图示**：

- **插入节点（头部插入）**：

假设要在上述双链表头部插入数据为 `0` 的节点。

```
     +---+    +---+    +---+    +---+    +---+
NULL <- | 0 | <-> | 1 | <-> | 3 | <-> | 5 | <-> | 7 | -> NULL
     +---+    +---+    +---+    +---+    +---+
```

操作步骤：

1. 创建新节点存储数据 `0`。
2. 将新节点的 next 指针指向原头节点（存储 `1` 的节点）。
3. 将原头节点（存储 `1` 的节点）的 prev 指针指向新节点。
4. 将新节点设为头节点，此时链表的头指针指向新节点，且新节点的 prev 指针指向 NULL。

- **插入节点（中间插入，比如在 `3` 和 `5` 之间插入 `4`）**：

```
     +---+    +---+    +---+    +---+    +---+
NULL <- | 1 | <-> | 3 | <-> | 4 | <-> | 5 | <-> | 7 | -> NULL
     +---+    +---+    +---+    +---+    +---+
```

操作步骤：

1. 从链表头开始遍历，找到存储 `3` 的节点（插入位置的前驱节点）。
2. 创建新节点存储数据 `4`。
3. 将新节点的 next 指针指向存储 `5` 的节点（原前驱节点的下一个节点）。
4. 将存储 `5` 的节点的 prev 指针指向新节点。
5. 将存储 `3` 的节点的 next 指针指向新节点。
6. 将新节点的 prev 指针指向存储 `3` 的节点。

- **删除节点（删除头节点）**：

```
     +---+    +---+    +---+    +---+
NULL <- | 3 | <-> | 5 | <-> | 7 | -> NULL
     +---+    +---+    +---+    +---+
```

操作步骤：

1. 将头节点（存储 `1` 的节点）的下一个节点（存储 `3` 的节点）的 prev 指针设为 NULL。
2. 将头节点指向下一个节点（存储 `3` 的节点）。
3. 原头节点的存储空间可根据具体情况进行释放。

- **删除节点（删除中间节点，比如存储 `5` 的节点）**：

```
     +---+    +---+    +---+    +---+
NULL <- | 1 | <-> | 3 | <-> | 7 | -> NULL
     +---+    +---+    +---+    +---+
```

操作步骤：

1. 从链表头开始遍历，找到存储 `3` 的节点（要删除节点 `5` 的前驱节点）。
2. 将存储 `3` 的节点的 next 指针指向存储 `5` 的节点的下一个节点（存储 `7` 的节点）。
3. 将存储 `7` 的节点的 prev 指针指向存储 `3` 的节点。
4. 存储 `5` 的节点的存储空间可根据具体情况进行释放。

- **删除节点（删除尾节点）**：

```
     +---+    +---+    +---+    +---+
NULL <- | 1 | <-> | 3 | <-> | 5 | -> NULL
     +---+    +---+    +---+    +---+
```

操作步骤：

1. 将尾节点（存储 `7` 的节点）的前一个节点（存储 `5` 的节点）的 next 指针设为 NULL。
2. 将尾节点指向前一个节点（存储 `5` 的节点）。
3. 存储 `7` 的节点的存储空间可根据具体情况进行释放。

### 三、循环链表（Circular - Linked List）

**图示（单循环链表）**：

```
     +---+    +---+    +---+    +---+
     | 1 | -> | 3 | -> | 5 | -> | 7 |
     ^                       |
     +-----------------------+
```

在单循环链表中，最后一个节点的 next 指针指向头节点，形成一个环形结构。

**操作示例图示（单循环链表）**：

- **插入节点（头部插入）**：

假设要在上述单循环链表头部插入数据为 `0` 的节点。

```
     +---+    +---+    +---+    +---+    +---+
     | 0 | -> | 1 | -> | 3 | -> | 5 | -> | 7 |
     ^                       |
     +-----------------------+
```

操作步骤：

1. 创建新节点存储数据 `0`。
2. 将新节点的 next 指针指向原头节点（存储 `1` 的节点）。
3. 遍历找到尾节点（存储 `7` 的节点），将尾节点的 next 指针指向新节点。
4. 将新节点设为头节点。

- **插入节点（中间插入，比如在 `3` 和 `5` 之间插入 `4`）**：

```
     +---+    +---+    +---+    +---+    +---+
     | 1 | -> | 3 | -> | 4 | -> | 5 | -> | 7 |
     ^                       |
     +-----------------------+
```

操作步骤：

1. 从链表头开始遍历，找到存储 `3` 的节点（插入位置的前驱节点）。
2. 创建新节点存储数据 `4`。
3. 将新节点的 next 指针指向存储 `5` 的节点（原前驱节点的下一个节点）。
4. 将存储 `3` 的节点的 next 指针指向新节点。

- **删除节点（删除头节点）**：

```
     +---+    +---+    +---+    +---+
     | 3 | -> | 5 | -> | 7 | -> | 1 |
     ^                       |
     +-----------------------+
```

操作步骤：

1. 遍历找到尾节点（存储 `7` 的节点）。
2. 将尾节点的 next 指针指向头节点的下一个节点（存储 `3` 的节点）。
3. 更新头节点为存储 `3` 的节点。

- **删除节点（删除中间节点，比如存储 `5` 的节点）**：

```
     +---+    +---+    +---+    +---+
     | 1 | -> | 3 | -> | 7 | -> | 1 |
     ^                       |
     +-----------------------+
```

操作步骤：

1. 从链表头开始遍历，找到存储 `3` 的节点（要删除节点 `5` 的前驱节点）。
2. 将存储 `3` 的节点的 next 指针指向存储 `5` 的节点的下一个节点（存储 `7` 的节点）。

**图示（双循环链表）**：

```
     +---+    +---+    +---+    +---+
NULL <- | 1 | <-> | 3 | <-> | 5 | <-> | 7 | -> NULL
     ^                       |
     +-----------------------+
```

在双循环链表中，头节点的 prev 指针指向尾节点，尾节点的 next 指针指向头节点，形成环形。

**操作示例图示（双循环链表）**：

- **插入节点（头部插入）**：

假设要在上述双循环链表头部插入数据为 `0` 的了节点。

```
     +---+    +---+    +---+    +---+    +---+
NULL <- | 0 | <-> | 1 | <-> | 3 | <-> | 5 | <-> | 7 | -> NULL
     ^                       |
     +-----------------------+
```

操作步骤：

1. 创建新节点存储数据 `0`。
2. 将新节点的 next 指针指向原头节点（存储 `1` 的节点）。
3. 将原头节点（存储 `1` 的节点）的 prev 指针指向新节点。
4. 遍历找到尾节点（存储 `7` 的节点），将尾节点的 prev 指针指向新节点。
5. 将新节点设为头节点，此时新节点的 prev 指针指向尾节点（存储 `7` 的节点）。

- **插入节点（中间插入，比如在 `3` 和 `5` 之间插入 `4`）**：

```
     +---+    +---+    +---+    +---+    +---+
NULL <- | 1 | <-> | 3 | <-> | 4 | <-> | 5 | <-> | 7 | -> NULL
     ^                       |
     +-----------------------+
```

操作步骤：

1. 从链表头开始遍历，找到存储 `3` 的节点（插入位置的前驱节点）。
2. 创建新节点存储数据 `4`。
3. 将新节点的 next 指针指向存储 `5` 的代码节点（原前驱节点的下一个节点）。
4. 将存储 `5` 的节点的 prev 指针指向新节点。
5. 将存储 `3` 的节点的 next 指针指向新节点。
6. 将新项目的 prev 指针指向存储 `3` 的节点。
7. 遍历找到尾节点（存储 `7` 的节点），将尾节点的 prev 指针指向新节点。

- **删除节点（删除头节点）**：

```
     +---+    +---+    +---+    +---+
NULL <- | 3 | <-> | 5 | <-> | 7 | -> NULL
     ^                       |
     +-----------------------+
```

操作步骤：

1. 将头节点（存储 `1` 的节点）的下一个节点（存储 `3` 的节点）的 prev 指针设为 NULL。
2. 将头节点指向下一个节点（存储 `3` 的节点）。
3. 遍历找到尾节点（存储 `7` 的节点），将尾节点的 prev 指针指向新头节点（存储 `3` 的节点）。
4. 原头节点的存储空间可根据具体情况进行释放。

- **删除节点（删除中间节点，比如存储 `5` 的节点）**：

```
     +---+    +---+    +---+    +---+
NULL <- | 1 | <-> | 3 | <-> | 7 | -> NULL
     ^                       |
     +-----------------------+
```

操作步骤：

1. 从链表头开始遍历，找到存储 `3` 的节点（要删除节点 `5` 的前驱节点）。
2. 将存储 `3` 的节点的 next 指针指向存储 `5` 的节点的下一个节点（存储 `7` 的节点）。
3. 将存储 `7` 的节点的 prev 指针指向存储 `3` 的节点。
4. 遍历找到尾节点（存储 `7` 的节点），将尾节点的 prev 指针指向存储 `3` 的节点。
5. 存储 `5` 的节点的存储空间可根据具体情况进行释放。

- **删除节点（删除尾节点）**：

```
     +---+    +---+    +---+    +---+
NULL <- | 1 | <-> | 3 | <-> | 5 | -> NULL
     ^                       |
     +-----------------------+
```

操作步骤：

1. 将尾节点（存储 `7` 的节点）的前一个节点（存储 `5` 的节点）的 next 指针设为 NULL。
2. 将尾节点指向前一个节点（存储 `5` 的节点）。
3. 遍历找到头节点（存储 `1` 的节点），将头节点的 prev 指针指向新尾节点（存储 `5` 的节点）。
4. 存储 `7` 的节点的存储空间可根据具体情况进行释放。

# 链表不同分类的更多应用场景：

### 一、单链表（Singly - Linked List）

#### （一）动态数据存储

- 在一些简单的动态数据结构场景中，单链表可以方便地用于存储一系列数据元素，并且不需要预先知道数据的大小。例如，在一个简单的文本编辑器中，用于存储用户输入的字符序列。每个字符节点可以包含字符本身和指向下一个字符节点的指针，当用户输入新字符时，可以在链表末尾插入新节点来扩展存储。

#### （二）函数调用栈（简易模拟）

- 可以用于简易模拟函数调用栈。在程序执行过程中，当一个函数被调用时，相关的信息（如返回地址、局部变量等）可以被封装成一个节点插入到链表头部（模拟栈顶）。当函数返回时，从链表头部（栈顶）删除节点。这种方式可以帮助理解函数调用和返回的过程，不过在实际应用中，操作系统和编程语言通常有更复杂和高效的栈管理机制。

#### （三）多项式表示

- 用于表示多项式。例如，对于多项式 $3x^2 + 5x + 7$，可以用单链表来存储。每个节点可以包含系数和指数两个部分，按照指数从高到低（或者从低到高）的顺序连接节点。这样的表示方式方便多项式的加法、减法和乘法等运算，通过遍历链表并按照多项式运算规则操作节点来实现。

### 二、双链表（Doubly - Linked List）

#### （一）双向遍历数据结构

- 在需要双向遍历的数据集合中非常有用。例如，在一个音乐播放列表应用中，双链表可以用于存储歌曲列表。用户既可以按照顺序播放歌曲（从前往后遍历链表），也可以反向播放（从后往前遍历链表）。每个歌曲节点包含歌曲信息、指向前一首歌曲的指针和指向后一首歌曲的指针。

#### （二）缓存系统

- 在缓存系统中，双链表可以用于实现 LRU（Least Recently Used）缓存淘汰策略。将缓存的数据项存储在双链表中，当数据项被访问时，将其移动到链表头部（表示最近使用）。当缓存满需要淘汰数据时，从链表尾部（最久未使用）删除节点。这种方式可以有效地管理缓存空间，提高缓存命中率。

#### （三）文本编辑器的撤销/重做功能

- 在高级文本编辑器中，双链表可以用于实现撤销和重做功能。每一次用户的编辑操作（插入、删除等）可以看作一个节点，节点包含操作内容和反向操作内容。通过双链表的前后遍历，可以方便地实现撤销（向前遍历）和重做（向后遍历）操作。

### 三、循环链表（Circular - Linked List）

#### （一）循环任务调度

- 在操作系统的任务调度系统或者嵌入式系统的任务循环中可以应用。例如，有一组周期性执行的任务，如系统监控任务、数据采集任务等，这些任务可以存储在一个循环链表中。操作系统或嵌入式系统按照链表顺序依次执行任务，当执行到链表尾部时，自动跳转到头部开始下一轮任务执行，实现循环任务调度。

#### （二）游戏开发中的角色循环系统

- 在多人游戏开发中，对于角色的循环操作可以使用循环链表。例如，在一个回合制游戏中，玩家角色按照固定的顺序轮流进行操作。所有玩家角色可以存储在一个循环链表中，游戏引擎按照链表顺序激活每个角色进行操作，当所有角色都操作完一轮后，又从链表头部开始下一轮循环。

#### （三）资源循环利用系统

- 在资源管理系统中，如内存块管理或者图形渲染中的纹理资源管理。以内存块管理为例，可用的内存块可以用循环链表来存储。当需要分配内存时，从链表中取出一个节点（内存块）；当内存块被释放时，又将其插入到链表中，方便下一次分配，形成资源的循环利用。

# 链表的优点和缺点

## 一、单链表（Singly - Linked List）

### （一）优点

- **动态大小调整方便**：无需预先知晓数据总量，可按需灵活地创建新节点并调整指针来实现数据的动态扩展或收缩。例如在处理网络数据包接收这类数据量不固定的场景时，能便捷地逐个添加新的数据节点。
- **插入和删除操作相对灵活（在某些情况下）**：当明确插入或删除位置的前驱节点时，操作相对简便。特别是头部插入操作，其时间复杂度低至 $O(1)$。比如在构建简易栈结构时，利用单链表的头部插入和删除可高效达成入栈与出栈功能。

### （二）缺点

- **单向访问限制**：仅能沿着 next 指针所指方向遍历节点，若要访问某个节点的前驱节点，只能从链表头部起始遍历，这使得时间复杂度高达 $O(n)$。例如在依据单链表存储的历史操作记录进行撤销操作时，往往需要从链表头部开始查找当前操作节点的前驱节点。
- **查找效率较低**：缺乏类似数组的索引机制，在单链表中查找特定元素时，只能逐个节点依次比对，平均时间复杂度为 $O(n)$。例如在单链表存储的学生信息里查找特定学号的学生信息，最坏情形下需遍历整个链表。

## 二、双链表（Doubly - Linked List）

### （一）优点

- **双向遍历方便**：每个节点均设有指向前驱与后继节点的指针，无论是从前往后还是从后往前遍历节点，时间复杂度均为 $O(n)$，在频繁访问前驱节点的场景中，相比单链表更具效率。例如在支持双向翻页的文档浏览结构里，双链表可良好地支撑此类操作。
- **插入和删除操作灵活（在更多情况下）**：在已知操作位置的前驱或后继节点时，双链表的插入和删除操作较为简易，且时间复杂度可维持在 $O(1)$（暂不考虑查找插入或删除位置所耗费的时间）。例如在具备双向编辑功能的文本编辑器中，双链表能够便捷地实现字符的插入与删除操作，并且在撤销或恢复编辑操作时，也能够高效地调整链表结构。

### （二）缺点

- **额外的空间开销**：双链表的每个节点需存储两个指针（prev 和 next），相较于单链表，其占用的存储空间更多。当存储大规模数据时，这种额外的空间消耗将更为显著。例如对于存储大量整数的链表场景，若单链表中每个整数占用 4 字节，指针占用 4 字节，即单链表每个节点共占用 8 字节；而双链表每个节点则需占用 12 字节。
- **操作相对复杂**：双链表在执行插入和删除操作时，涉及更多指针的调整与维护，尽管在特定情形下时间复杂度与单链表相同，但在代码编写过程中，更容易因指针操作失误而引发错误。例如在双链表中插入一个节点时，需要精准地设置新节点的 prev 和 next 指针，以及相邻节点的 prev 和 next 指针，任何一处指针设置错误都可能导致链表结构的混乱或错误。

## 三、循环链表（Circular - Linked List）

### （一）优点

- **循环遍历特性**：循环链表适用于需要循环处理数据的特定场景，其不存在明确的头节点和尾节点概念，从链表中的任意一个节点出发，均能够遍历整个链表。例如在实现循环播放音乐列表功能时，循环链表能够完美契合需求，用户可从任意一首歌曲开启播放流程，当播放至列表末尾的歌曲后，能够自动跳转回第一首歌曲并持续播放。
- **资源循环利用高效**：在部分资源管理相关的场景中，如内存块的分配与回收管理系统，循环链表能够便捷地实现资源的循环利用。当一个内存块资源被释放后，可迅速地重新插入至循环链表中，以便于下一次分配使用，从而有效降低资源碎片化的风险。例如在操作系统的内存管理模块里，对于空闲内存块的组织与管理，常采用循环链表结构来实现高效的资源循环利用。

### （二）缺点

- **终止条件判断复杂**：由于循环链表不存在明显的结尾标识，在对其进行遍历操作或执行其他相关操作时，需要格外谨慎地设置终止条件，否则极易引发无限循环的错误。例如在编写遍历循环链表的函数时，若未能正确设定循环终止条件，程序可能会陷入无休止的循环，进而导致程序崩溃或陷入死循环状态，严重影响程序的正常运行与稳定性。
- **与其他数据结构的集成可能受限**：循环链表的循环特性可能导致其在与一些基于线性结构设计或者具有明确开头与结尾要求的算法或数据结构进行集成整合时面临困难。例如在将循环链表中的数据传递给一个仅能处理非循环线性结构的排序算法时，往往需要预先进行额外的处理步骤，将循环链表转换为非循环结构，方能确保排序算法能够正确运行，这无疑增加了系统设计与开发的复杂性与难度。


# 一、树的定义

树是一种非线性的数据结构。它由节点（Node）和边（Edge）组成，有一个特殊的节点称为根节点（Root），其余节点通过边连接，并且每个节点可以有零个或多个子节点。树是一种层次结构，类似于自然界中的树，从根节点开始，不断分支延伸。

# 二、树的基本术语

- **节点（Node）**：树中的元素，包含数据和指向子节点的指针（在具体实现中）。例如，在存储员工组织架构的树中，每个员工可以看作一个节点。
- **边（Edge）**：连接两个节点的线段，表示节点之间的关系。例如，在公司部门层级树中，连接部门经理节点和下属员工节点的就是边。
- **根节点（Root）**：树的起始节点，没有父节点。比如在家族族谱树中，最早的祖先就是根节点。
- **子节点（Child Node）和父节点（Parent Node）**：如果存在一条边从节点A指向节点B，那么B是A的子节点，A是B的父节点。例如，在文件系统的目录树中，文件夹下的文件是该文件夹的子节点，文件夹是文件的父节点。
- **叶子节点（Leaf Node）**：没有子节点的节点。在组织结构树中，最底层的员工节点可能就是叶子节点。
- **兄弟节点（Sibling Node）**：具有相同父节点的节点。例如，同一部门下的员工节点是兄弟节点。
- **路径（Path）**：从一个节点到另一个节点经过的边的序列。例如，在树状的网站导航结构中，从首页节点到某个产品详情页节点经过的一系列连接就是路径。
- **深度（Depth）**：从根节点到某个节点的路径长度（边的数量）。根节点的深度为0，它的子节点深度为1，以此类推。例如，在多层级的分类树中，最深层的节点深度较大。
- **高度（Height）**：树中节点的最大深度加1。也可以理解为从叶子节点到根节点最长路径上的节点数。例如，一棵有3层的树，高度为3。

# 三、二叉树（一种特殊的树）

二叉树是树结构的一种特殊情况，每个节点最多有两个子节点，分别称为左子节点和右子节点。

## （一）图示

```
       1
     /   \
    2     3
   / \   / \
  4   5 6   7
```

在这个二叉树示例中：
- 节点1是根节点。
- 节点2和3是节点1的子节点，节点1是它们的父节点。
- 节点4和5是节点2的子节点，节点2是它们的父节点；节点6和7是节点3的子节点，节点3是它们的父节点。
- 节点4、5、6、7是叶子节点。
- 节点2和3是兄弟节点，节点4和5是兄弟节点，节点6和7是兄弟节点。

## （二）二叉树的遍历

### 1. 前序遍历
- **定义**：先访问根节点，然后递归地访问左子树，再访问右子树。
- **遍历顺序（以上图为例）**：1 -> 2 -> 4 -> 5 -> 3 -> 6 -> 7
- **应用场景**：在表达式求值中，如果二叉树用于表示算术表达式（运算符为根节点，操作数为子节点），前序遍历可以得到前缀表达式。

### 2. 中序遍历
- **定义**：先递归地访问左子树，然后访问根节点，再访问右子树。
- **遍历顺序（以上图为例）**：4 -> 2 -> 5 -> 1 -> 6 -> 3 -> 7
- **应用场景**：对于二叉搜索树（一种特殊的二叉树，左子树节点值小于根节点值，右子树节点值大于根节点值），中序遍历可以得到有序的数据序列，这在数据排序和查找中有重要应用。

### 3. 后序遍历
- **定义**：先递归地访问左子树，然后访问右子树，最后访问根节点。
- **遍历顺序（以上图为例）**：4 -> 5 -> 2 -> 6 -> 7 -> 3 -> 1
- **应用场景**：在计算树的叶子节点相关的属性（如计算表达式树的结果，先计算子表达式的值）或者释放树节点的资源时很有用。

# 四、多叉树（一般树）

多叉树是每个节点可以有多个子节点的树结构。

## （一）图示

```
       1
     / | \
    2  3  4
   / \    |
  5   6   7
       \
        8
```

在这个多叉树示例中：
- 节点1是根节点。
- 节点2、3、4是节点1的子节点。
- 节点5、6是节点2的子节点，节点7是节点4的子节点，节点8是节点6的子节点。
- 节点5、6、7、8是叶子节点。

## （二）多叉树的遍历
- 多叉树的遍历方式与二叉树类似，但由于子节点数量不固定，在实现遍历算法时需要考虑如何遍历所有子节点。一般可以使用递归或者队列辅助的方式进行遍历。例如，广度优先遍历可以使用队列来存储每层的节点，按照层次顺序依次访问节点；深度优先遍历可以使用递归或者栈来实现，沿着一条路径尽可能深地访问节点，然后回溯。

## （三）应用场景
- 多叉树在文件系统、组织结构图、语法树等众多场景中有广泛应用。例如，在文件系统中，目录可以看作是树的节点，文件是叶子节点，目录之间的包含关系通过树的边来表示；在语法树中，语法规则通过树的结构来体现，用于编译原理中的语法分析。

# 二叉树的分类

## 一、满二叉树

### （一）定义
- 满二叉树是一种特殊的二叉树，除了最后一层的叶子节点外，每一层的节点数都达到最大值。并且最后一层的叶子节点都集中在最左边。也就是说，如果二叉树的深度为 $h$（根节点深度为 $0$），那么满二叉树的节点总数为 $2^{h + 1}-1$。

### （二）图示
```
       1
     /   \
    2     3
   / \   / \
  4   5 6   7
 / \ / \
8  9 10 11
```
- 在这个满二叉树示例中，深度为 $3$，节点总数为 $2^{3 + 1}-1 = 15$。每一层的节点数依次为 $1$、$2$、$4$、$8$，符合满二叉树的定义。

### （三）应用场景
- **编码理论**：在哈夫曼编码中，满二叉树可以用于构建最优前缀码。当所有字符出现的频率相等时，满二叉树结构可以帮助我们快速生成编码，使得编码长度最短且具有前缀性质，方便数据的压缩和传输。
- **并行计算资源分配模型**：可以将满二叉树看作是一种资源分配模型。例如，在具有多个处理器的并行计算系统中，满二叉树的每一层可以代表不同级别的任务分配，根节点为总任务分配器，叶子节点为实际执行计算任务的处理器，这种结构有助于高效地分配和管理计算任务。

## 二、完全二叉树

### （一）定义
- 完全二叉树是一种效率很高的数据结构。它的特点是除了最后一层外，前面每一层的节点数都是满的，最后一层的节点从左到右依次排列。可以把完全二叉树看作是满二叉树在最后一层从右向左删除若干节点得到的。

### （二）图示
```
       1
     /   \
    2     3
   / \   / 
  4   5 6   
```
- 这个二叉树是完全二叉树，它的前两层是满的，最后一层节点从左到右依次排列，没有间隙。如果给这个二叉树添加一个右子节点到节点 $6$，它依然是完全二叉树；但如果在节点 $4$ 和 $5$ 之间插入一个新节点，就不再是完全二叉树了。

### （三）应用场景
- **堆数据结构实现**：完全二叉树是实现堆（包括最大堆和最小堆）的理想结构。在堆中，父节点与子节点之间有特定的大小关系（最大堆中父节点大于等于子节点，最小堆中父节点小于等于子节点）。由于完全二叉树的特性，我们可以使用数组来高效地存储堆中的节点，通过简单的索引计算就能快速访问父节点和子节点，这种结构在优先级队列等应用场景中非常重要，如操作系统中的进程调度（按照优先级高低安排进程执行顺序）。
- **二叉树的顺序存储**：因为完全二叉树的节点编号与数组索引之间有很自然的对应关系，所以在需要将二叉树存储在顺序存储结构（如数组）中时，完全二叉树是最合适的。这种存储方式可以减少存储空间的浪费，并且方便进行一些遍历操作和节点访问操作。

## 三、二叉搜索树（BST - Binary Search Tree）

### （一）定义
- 二叉搜索树是一种有序的二叉树。对于树中的任意一个节点，其左子树中的所有节点的值都小于该节点的值，其右子树中的所有节点的值都大于该节点的值。这使得在二叉搜索树中进行查找、插入和删除操作都比较高效。

### （二）图示
```
       8
     /   \
    3     10
   / \     \
  1   6     14
     / \    /
    4   7  13
```
- 在这个二叉搜索树示例中，以节点 $8$ 为例，它的左子树节点（$3$、$1$、$6$、$4$、$7$）的值都小于 $8$，右子树节点（$10$、$14$、$13$）的值都大于 $8$。这种有序性使得查找一个特定值时，可以根据节点值的大小关系快速定位到目标节点可能存在的子树，减少不必要的搜索路径。

### （三）应用场景
- **数据存储与查找**：广泛应用于数据库索引、文件系统目录结构等场景。在数据库中，二叉搜索树可以用于构建索引，加快数据的查找速度。例如，在一个存储学生成绩的数据库中，以学生学号为键构建二叉搜索树索引，当需要查找某个学生的成绩时，可以快速定位到相应的存储位置。
- **动态数据集合维护**：在需要频繁插入和删除元素，并且需要保持元素有序的场景中，二叉搜索树是很好的选择。例如，在一个实时股票交易系统中，需要根据股票代码来管理交易订单，二叉搜索树可以方便地插入新订单、删除已完成的订单，并快速查找特定股票代码的订单信息。

## 四、平衡二叉树（AVL树 - Adelson - Velskii and Landis Tree）

### （一）定义
- 平衡二叉树是一种特殊的二叉搜索树，它的左右子树的高度差绝对值不超过 $1$。通过动态调整树的结构来保持平衡，这样可以保证在最坏情况下，基本操作（如查找、插入、删除）的时间复杂度依然是 $O(log n)$，其中 $n$ 是树中的节点数。

### （二）图示（简单示意平衡调整过程）

### 1. 插入节点导致不平衡（右旋操作示例）
- 假设初始是一个平衡的二叉搜索树：
```
       4
     /   \
    2     6
   / \   / \
  1   3 5   7
```
- 插入节点 $8$，导致以节点 $6$ 为根的子树不平衡：
```
       4
     /   \
    2     6
   / \   / \
  1   3 5   7
         \
          8
```
- 进行右旋操作来恢复平衡：
```
       4
     /   \
    2     7
   / \   / \
  1   3 6   8
        /
       5
```

### 2. 另一种不平衡情况（左旋操作示例）
- 假设初始是一个平衡的二叉搜索树：
```
       6
     /   \
    4     8
   / \   / \
  3   5 7   9
```
- 插入节点 $2$，导致以节点 $4$ 为根的子树不平衡：
```
       6
     /   \
    4     8
   / \   / \
  3   5 7   9
 /
2
```
- 进行左旋操作来恢复平衡：
```
       6
     /   \
    4     8
   / \   / \
  2   5 7   9
   \
    3
```

### （三）应用场景
- **高效的数据查找与更新**：在对数据的查找和更新操作效率要求较高的场景中，平衡二叉树是很好的选择。例如，在编译器的符号表管理中，需要频繁地查找和插入标识符，平衡二叉树可以保证这些操作在最坏情况下也能有较好的时间复杂度，提高编译器的性能。
- **需要稳定性能的数据结构**：由于平衡二叉树能够保证在任何情况下基本操作的时间复杂度都比较稳定，所以在一些对性能稳定性要求较高的系统中得到应用。比如，在网络路由表的维护中，需要快速查找和更新路由信息，平衡二叉树可以避免因为数据插入或删除导致树的结构失衡，从而保证路由查找的效率。

## 五、红黑树（Red - Black Tree）

### （一）定义
- 红黑树是一种自平衡的二叉搜索树，它在每个节点上增加了一个颜色属性（红色或黑色），并且通过一些规则来保证树的平衡。这些规则包括：
    - 每个节点要么是红色，要么是黑色。
    - 根节点是黑色。
    - 每个叶子节点（空节点）是黑色。
    - 如果一个节点是红色的，则它的子节点必须是黑色。
    - 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点。

### （二）图示（简单示意红黑树结构）
```
       (B)8
     /     \
  (R)3     (B)10
   / \     /  \
 (B)1 (B)6 (B)9  (B)14
       / \       /
    (R)4   (R)7  (B)13
```
- 在这个红黑树示例中，括号内表示节点的颜色。通过这些颜色规则来保证树的平衡性，使得红黑树在插入、删除等操作后能够通过一些旋转和颜色调整操作来保持平衡，从而保证操作的高效性。红黑树在很多编程语言的标准库中用于实现集合（Set）和映射（Map）等数据结构，如Java中的TreeSet和TreeMap。

### （三）应用场景
- **实现关联容器**：在编程语言的标准库中，红黑树常用于实现关联容器，如`std::map`和`std::set`（在C++ 中）等。这些容器需要在插入、删除和查找操作时保持高效性，红黑树的平衡特性能够满足这一需求。例如，在一个地图软件中，使用红黑树来存储地图上的地点信息（以地点名称为键），方便快速查找、添加和删除地点。
- **系统资源管理**：在操作系统的内存管理中，红黑树可以用于管理内存块。每个内存块可以看作是红黑树的一个节点，通过红黑树的结构来快速查找空闲内存块、分配内存以及回收内存，并且在内存块的动态分配和回收过程中保持树的平衡，提高内存管理的效率。

# 一、B - 树

## （一）定义与结构
- B - 树是平衡多路搜索树，m阶B - 树（m≥3）节点有特性：非根非叶节点孩子节点数在$\lceil m/2\rceil$到m之间，节点含关键字和指向子节点指针，关键字数比子节点数少1。

## （二）操作特点
- **查找**：从根开始，对比关键字找匹配或确定子树继续找，时间复杂度$O(log_m n)$。
- **插入**：先找插入位置（叶子节点），超容量需分裂节点并可能调整父节点，最坏情况时间复杂度$O(log_m n)$。
- **删除**：找到关键字所在节点，按情况处理，可能需合并或调整节点，最坏情况时间复杂度$O(log_m n)$。

## （三）应用场景
- 用于数据库索引和文件系统，可加快查询速度、定位文件存储位置等。

# 二、B + 树

## （一）定义与结构
- B + 树是B - 树变形，非叶子节点只存索引关键字，数据记录全在叶子节点且叶子节点间有链表连接。

## （二）操作特点
- **查找**：类似B - 树，从根找起，最后在叶子节点确定结果，时间复杂度$O(log_m n)$。
- **插入**：找插入位置到叶子节点插入，满了要分裂并维护链表关系，最坏情况时间复杂度$O(log_m n)$。
- **删除**：找到叶子节点删数据，关键字少了要合并或调整并维护链表关系，最坏情况时间复杂度$O(log_m n)$。

## （三）应用场景
- 适合数据库索引（尤其范围查询）及大型存储系统索引结构，方便范围查询及定位数据。

# 三、B*树

## （一）定义与结构
- B*树是B + 树改进，除叶子节点有链表连接外，非叶子节点间也有连接，节点合并分裂策略不同。

## （二）操作特点
- **查找**：类似B + 树，因非叶子节点连接有时可更快定位，时间复杂度$O(log_m n)$。
- **插入**：尽量推迟分裂，快满时先借关键字，借不到才分裂，最坏情况时间复杂度$O(log_m n)$。
- **删除**：尽量推迟合并，关键字少了先取关键字，取不到才合并，最坏情况时间复杂度$O(log_m n)$。

## （三）应用场景
- 用于对数据库性能要求极高场景及大型数据存储检索系统，可提升性能。

# 四、LSM树（Log - Structured Merge - Tree）

## （一）定义与结构
- LSM树由内存数据结构（如跳表、红黑树等）和磁盘上的SSTable组成，数据先写内存，达条件后合并写入磁盘SSTable。

## （二）操作特点
- **写入**：速度快，先写内存避频繁磁盘I/O，但有数据丢失风险（可降低）。
- **读取**：较复杂，需从内存和SSTable找数据，时间复杂度依数据分布情况。
- **合并**：定期合并SSTable，耗时但可优化存储结构提升性能。

## （三）应用场景
- 是许多NoSQL数据库存储引擎核心结构，也用于分布式存储系统（对写入性能要求高场景）。

# B- 树与B+树的区别：

1. **数据存储位置**
    - **B - 树**：数据存储在每个节点，包括关键字和记录。
    - **B + 树**：非叶子节点只存关键字用于索引，数据记录都在叶子节点，且叶子节点间有链表连接。
2. **节点结构与关键字数量关系**
    - **B - 树**：m阶B - 树节点孩子节点和关键字数量有规定关系，关键字数比孩子节点数少1。
    - **B + 树**：m阶B + 树类似，但应用场景中m取值可能不同，非叶子主要用于索引。
3. **查询操作特点**
    - **B - 树**：从根开始比较关键字确定搜索路径，可能在非叶子节点找到数据。范围查询较复杂。
    - **B + 树**：从根找叶子节点获取数据。范围查询有优势，可沿叶子链表读取数据，减少磁盘I/O。
4. **插入和删除操作特点**
    - **B - 树**：
        - **插入**：找叶子插入，超上限要分裂节点和调整父节点。
        - **删除**：找到节点删除，可能要替换关键字，之后可能合并或调整节点。
    - **B + 树**：
        - **插入**：找叶子插入，满了要分裂且维护叶子链表。
        - **删除**：在叶子删除，关键字少了要合并或调整，维护叶子链表。
5. **应用场景侧重点**
    - **B - 树**：适用于单个数据查询和更新频繁、范围查询要求不高场景。
    - **B + 树**：用于数据库索引（尤其范围查询）和存储系统索引，方便范围查询和顺序访问。

    # B - 树和B + 树的区别

## 一、B - 树图示

假设我们有一个3阶B - 树（每个节点最多有3个孩子节点，除根节点和叶子节点外，每个节点至少有2个孩子节点），用于存储整数数据。

```
        10
      /   |   \
     5    12    15
    / \   |    / \
   3   7  13   14  18
```

1. **数据存储位置**
   - 在这个B - 树示例中，数据（整数）和关键字是一体的，都存储在各个节点中。例如，根节点存储关键字10，同时这个节点也存储了划分数据范围的信息。左子树中的数据（3、5、7）都小于10，中间子树中的数据（12、13）大于10且小于15，右子树中的数据（14、15、18）大于15。
2. **节点结构与关键字数量关系**
   - 可以看到每个节点的关键字数量比孩子节点数量少1。如根节点有3个孩子节点，2个关键字（10划分了左右两个范围，12划分了中间和右边的范围）。非根非叶节点至少有2个孩子节点，如存储5的节点有2个孩子节点（3和7），1个关键字。
3. **查询操作特点**
   - 若要查询数据13，从根节点开始比较。13大于10，所以在根节点的右子树中查找；13小于15，所以在中间子树（以12为关键字的子树）中查找，最终找到13。范围查询（如查询大于7且小于14的数据）需要遍历多个节点的子树，比较复杂。
4. **插入和删除操作特点（简单示意）**
   - **插入**：例如插入数据8，先找到合适的叶子节点（以5为关键字的节点），插入后该节点变为`3,5,7,8`，超过了3 - 1 = 2个关键字的限制，需要进行分裂操作。可能会将`3,5`作为一个节点，`7,8`作为一个新节点，同时调整父节点（根节点）的关键字和孩子节点指针。
   - **删除**：若要删除数据7，找到存储7的叶子节点，直接删除。如果删除后节点关键字数量过少，可能需要合并节点或者从相邻节点借关键字来调整树的结构。

## 二、B + 树图示

假设我们有一个3阶B + 树，同样用于存储整数数据。

```
         10
       /   |   \
      5    12    15
     / \   |    / \
    3   7  13   14  18
   |----|----|----|----|
   3,5,7 12,13 14,15,18
```

1. **数据存储位置**
   - 在B + 树中，非叶子节点（如`10`、`5`、`12`、`15`这些节点）只存储关键字用于索引。所有的数据都存储在叶子节点，并且叶子节点通过链表连接（这里用`|----|`示意）。例如，数据`3`、`5`、`7`存储在最左边的叶子节点，`12`、`13`存储在中间的叶子节点，`14`、`15`、`18`存储在最右边的叶子节点。
2. **节点结构与关键字数量关系**
   - 和B - 树类似，非叶子节点的关键字数量和孩子节点数量也有一定关系。但重点是叶子节点存储了实际的数据，并且为了方便范围查询，叶子节点之间是有序的且有链表连接。
3. **查询操作特点**
   - 查询数据13时，从根节点开始，沿着索引路径找到中间的叶子节点，在叶子节点中获取数据。对于范围查询（如查询大于7且小于14的数据），可以从左边第一个大于7的叶子节点（存储`12`、`13`的节点）开始，沿着叶子节点链表顺序读取，直到遇到大于等于14的数据，这样能高效地进行范围查询，减少磁盘I/O次数。
4. **插入和删除操作特点（简单示意）**
   - **插入**：例如插入数据9，先找到合适的叶子节点（存储`12`、`13`的节点）插入。如果这个叶子节点已满，需要进行分裂操作，同时要维护叶子节点之间的链表关系。假设插入9后，该叶子节点变为`9,12,13`，超过了3 - 1 = 2个关键字的限制，可能会将`9`作为一个新的叶子节点，`12,13`作为另一个叶子节点，并且正确地调整链表和非叶子节点的索引。
   - **删除**：若要删除数据13，在叶子节点（存储`12,13`的节点）中删除。如果删除后叶子节点关键字数量过少，可能需要合并叶子节点或者从相邻叶子节点获取关键字，同时维护叶子节点之间的链表关系。